{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"./data.service\"; // If we have no idea what to set these to, use these defaults\n\nconst DEFAULT_NUM_LETTERS = 3;\nconst DEFAULT_NUM_HOPS = 3;\nexport let GameService = /*#__PURE__*/(() => {\n  class GameService {\n    constructor(dataService) {\n      this.dataService = dataService; // The game board - array of words each of which has:\n      //   .letters = array of the letters of the word\n      //   .locked = true if this word cannot be changed\n      //   .solved = true if this word is verified\n      //   .wrong = word was tested and is wrong\n      //   .testing = word is currently being tested\n      //   .loading = word is being loaded\n      //   .populated = word is fully populated (all letters)\n      //   .broken = server problem, try again\n\n      this._board = []; // Status of the game:  run, win, broken, initialize\n\n      this._gameStatus = 'initialize'; // If something has requested a change to these values, store them until the next game starts\n\n      this._numLettersForNextGame = DEFAULT_NUM_LETTERS;\n      this._numHopsForNextGame = DEFAULT_NUM_HOPS; // Selected row/cell indexes\n\n      this._selectedWord = 1;\n      this._selectedLetter = 0; // Message back from the validation routines\n\n      this._message = '';\n      this.newGame();\n    }\n\n    newGame() {\n      this._gameStatus = 'initialize'; // Reset the number of letters / hops to any stored value\n\n      this._numLetters = this._numLettersForNextGame;\n      this._numHops = this._numHopsForNextGame;\n      console.log('Initialize new game: letters = ' + this._numLetters + ' / hops = ' + this._numHops);\n      console.log('Requesting word pair...');\n      this._board = this.createEmptyBoard();\n      this._message = 'Requesting a pair of words...';\n      this.dataService.getPair(this.numLetters, this._numHops) // resp is of type `HttpResponse<WordPair>`\n      .subscribe({\n        next: wordpair => {\n          this.wordPair = Object.assign({}, wordpair);\n          this._lastExecutionTime = this.wordPair.executionTime;\n          console.log('Got wordpair: ' + JSON.stringify(this.wordPair));\n          this.populateBoard();\n          this._message = ''; // Reset the current word/cell to the top\n\n          this._selectedWord = 1;\n          this._selectedLetter = 0;\n        },\n        error: err => {\n          // An error happened trying to get words\n          // The game is broken\n          this._gameStatus = 'broken'; // The words are no longer loading\n\n          for (const word of this._board) {\n            word.loading = false;\n          } // Show a message\n\n\n          this._message = 'Failed to communicate with the server, please try again later.';\n          console.log('Error getting words: ' + JSON.stringify(err));\n        }\n      });\n    }\n\n    createEmptyBoard() {\n      // Create a 2d board holding correct number words and letters each / all nulls\n      let board = [];\n\n      for (let i = 0; i < this._numHops + 1; i++) {\n        board[i] = {\n          letters: [],\n          locked: false,\n          solved: false,\n          wrong: false,\n          testing: false,\n          loading: false,\n          populated: false,\n          broken: false\n        };\n\n        for (let j = 0; j < this._numLetters; j++) {\n          board[i].letters.push(null);\n        }\n      } // First and last words are locked\n\n\n      board[0].locked = true;\n      board[this._numHops].locked = true; // First and last words are loading\n\n      board[0].loading = true;\n      board[this._numHops].loading = true;\n      return board;\n    }\n\n    populateBoard() {\n      // Fill in the first & last words on the board\n      for (let j = 0; j < this._numLetters; j++) {\n        this.board[0].letters[j] = this.wordPair.startWord.charAt(j);\n        this.board[this._numHops].letters[j] = this.wordPair.endWord.charAt(j);\n      } // First and last words are populated\n\n\n      this.board[0].populated = true;\n      this.board[this._numHops].populated = true; // First and last words are not loading\n\n      this.board[0].loading = false;\n      this.board[this._numHops].loading = false; // Game is ready to go\n\n      this._gameStatus = 'run';\n    } // Keyboard entry occurred\n\n\n    letterEntered(letter) {\n      if (!this._board[this._selectedWord].locked) {\n        // Backspace & Delete (mostly shared logic)\n        if (letter === 'Backspace' || letter === '{bksp}' || letter === 'Delete') {\n          // When you change a letter, the previous message goes away\n          this._message = ''; // Remove the letter from the current cell\n\n          this._board[this._selectedWord].letters[this._selectedLetter] = null; // The word is no longer fully populated\n\n          this._board[this._selectedWord].populated = false; // When you delete or backspace, this word is no longer solved\n\n          this._board[this._selectedWord].solved = false; // When you delete or backspace, this word is no longer wrong\n\n          this._board[this._selectedWord].wrong = false; // Backspace moves the current cell where delete doesn't\n\n          if (letter === 'Backspace' || letter === '{bksp}') {\n            // Back up to the previous cell\n            if (this._selectedLetter > 0) {\n              // Same word, 1 char backwards\n              this._selectedLetter--;\n            }\n          }\n\n          return;\n        } // Enter key\n\n\n        if (letter === 'Enter' || letter === '{enter}') {\n          // If all letters of this word are filled in, test the word\n          if (this._board[this._selectedWord].populated) {\n            // When you hit enter, the previous message goes away\n            this._message = ''; // We know the current word is filled in\n            // Need to determine if you test 1 word or all of them\n            // Validate a single word\n\n            this.testSingleWord();\n          }\n        } // Letters\n\n\n        let found = letter.match(/^[a-z]$/gi);\n\n        if (found) {\n          // Valid letter, put it in the appropriate cell\n          this._board[this._selectedWord].letters[this._selectedLetter] = letter.toUpperCase(); // When you change a letter, this word is no longer wrong or solved\n\n          this._board[this._selectedWord].wrong = false;\n          this._board[this._selectedWord].solved = false; // Check to see if the word is fully populated\n\n          let populated = true;\n\n          for (const letter of this._board[this._selectedWord].letters) {\n            if (letter == null) {\n              populated = false;\n            }\n          }\n\n          if (populated) this._board[this._selectedWord].populated = true; // When you change a letter, the previous message goes away\n\n          this._message = ''; // Move the input to the next appropriate cell\n\n          if (this._selectedLetter === this._numLetters - 1) {// Move to check button\n          } else {\n            // Move 1 to the right\n            this._selectedLetter++;\n          }\n        } // Arrow keys\n\n\n        if (letter === 'ArrowUp') {\n          if (this._selectedWord > 1) this._selectedWord--;\n        }\n\n        if (letter === 'ArrowDown') {\n          if (this._selectedWord < this._numHops - 1) this._selectedWord++;\n        }\n\n        if (letter === 'ArrowLeft') {\n          if (this._selectedLetter > 0) this._selectedLetter--;\n        }\n\n        if (letter === 'ArrowRight') {\n          if (this._selectedLetter < this._numLetters - 1) this._selectedLetter++;\n        }\n      }\n    } // Async call to test a single word\n\n\n    testSingleWord() {\n      // Output from remote call\n      let testedWord; // Inputs to remote call\n\n      let wordArray = [];\n\n      for (let i = 0; i < this._board.length; i++) {\n        // WordArray includes everything except the testing word\n        if (i != this._selectedWord) {\n          wordArray.push(this._board[i].letters.join(''));\n        } else {\n          wordArray.push('');\n        }\n      }\n\n      let testWord = this._board[this._selectedWord].letters.join('');\n\n      let testPosition = this._selectedWord; // Mark the word as currently being tested, not solved, not wrong\n\n      this._board[this._selectedWord].testing = true;\n      this._board[this._selectedWord].solved = false;\n      this._board[this._selectedWord].wrong = false; // Make the remote call\n\n      this.dataService.testWord(wordArray, testWord, testPosition).subscribe({\n        next: testedWord => {\n          // Test is done\n          this._board[testedWord.testPosition].testing = false; // The test word is not broken\n\n          this._board[testedWord.testPosition].broken = false;\n          this._lastExecutionTime = testedWord.executionTime;\n\n          if (testedWord.valid) {\n            // Word is solved, not wrong\n            this._board[testedWord.testPosition].solved = true;\n            this._board[testedWord.testPosition].wrong = false; // If all words are solved, you win\n\n            let puzzleFilledIn = true;\n\n            for (const word of this._board) {\n              if (!word.locked && !word.solved) {\n                puzzleFilledIn = false;\n              }\n            }\n\n            if (puzzleFilledIn) {\n              // You win!  Call this to report the completion.\n              this.win();\n            } else {\n              // Move to the next word (unless the user has already moved)\n              if (this._selectedWord == testedWord.testPosition) {\n                if (this._selectedWord < this._numHops - 1) {\n                  // Need to avoid moving to a solved word.\n                  // Start at the next word and move forwards.\n                  for (let i = testedWord.testPosition + 1; i < this._numHops; i++) {\n                    this._board[i].solved == false;\n                    this._selectedWord = i;\n                    this._selectedLetter = 0;\n                    break;\n                  }\n                }\n              }\n            }\n\n            return;\n          } else {\n            // Word is wrong, not solved\n            this._board[testedWord.testPosition].solved = false;\n            this._board[testedWord.testPosition].wrong = true;\n            this._message = testedWord.error;\n          }\n        },\n        error: err => {\n          // An error happened trying to get words\n          // Test is done\n          this._board[testPosition].testing = false; // The test word is broken\n\n          this._board[testPosition].broken = true; // Show a message\n\n          this._message = 'Failed to communicate with the server, please try again later.';\n          console.log('Error testing word: ' + JSON.stringify(err));\n        }\n      });\n    } // Async call to test the whole puzzle\n    // I think I'm going to use this to report a completion\n\n\n    win() {\n      this._gameStatus = 'win';\n      this._message = '!!! YOU WIN !!!';\n    } // Get a hint for the current word\n    // Send the request in without the current word.  When the reply comes back, clear\n    // the word and put that letter in the right place.\n\n\n    getHint() {\n      // Output from remote call\n      let wordHint; // Inputs to remote call\n\n      let wordArray = [];\n\n      for (let i = 0; i < this._board.length; i++) {\n        // WordArray includes everything including the partial word (spaces filled in)\n        // Handle an incomplete word\n        let incWord = '';\n\n        for (const letter of this._board[i].letters) {\n          if (letter != null) {\n            incWord += letter;\n          } else {\n            incWord += ' ';\n          }\n        }\n\n        wordArray.push(incWord);\n      }\n\n      let hintPosition = this._selectedWord; // Mark the word as currently being tested, not solved, not wrong\n\n      this._board[this._selectedWord].testing = true;\n      this._board[this._selectedWord].solved = false;\n      this._board[this._selectedWord].wrong = false; // Make the remote call\n\n      this.dataService.getHint(wordArray, hintPosition).subscribe({\n        next: wordHint => {\n          console.log('Got hint: ' + JSON.stringify(wordHint)); // Test is done\n\n          this._board[wordHint.hintWord].testing = false; // The test word is not broken\n\n          this._board[wordHint.hintWord].broken = false;\n          this._lastExecutionTime = wordHint.executionTime;\n\n          if (wordHint.valid) {\n            // Word is solved, not wrong\n            this._board[wordHint.hintWord].solved = false;\n            this._board[wordHint.hintWord].wrong = false; // Plug in the hint by moving to the cell and typing (to get other events)\n\n            this.setSelectedCell(wordHint.hintWord, wordHint.hintPosition);\n            this.letterEntered(wordHint.hintLetter);\n            return;\n          } else {\n            // Couldn't get a hint, tell the player\n            this._message = wordHint.error;\n          }\n        },\n        error: err => {\n          // An error happened trying to get words\n          // Test is done\n          this._board[hintPosition].testing = false; // The test word is broken\n\n          this._board[hintPosition].broken = true; // Show a message\n\n          this._message = 'Failed to communicate with the server, please try again later.';\n          console.log('Error testing word: ' + JSON.stringify(err));\n        }\n      });\n    } // Set the selected cell\n\n\n    setSelectedCell(word, letter) {\n      // Only move the selection if the word isn't locked\n      if (!this._board[word].locked) {\n        this._selectedWord = word;\n        this._selectedLetter = letter;\n      }\n    } /////\n    // Getters\n    /////\n\n\n    get board() {\n      return this._board;\n    }\n\n    get gameStatus() {\n      return this._gameStatus;\n    }\n\n    get selectedWord() {\n      return this._selectedWord;\n    }\n\n    set selectedWord(index) {\n      this._selectedWord = index;\n    }\n\n    get selectedLetter() {\n      return this._selectedLetter;\n    }\n\n    set selectedLetter(index) {\n      this._selectedLetter = index;\n    }\n\n    get numLetters() {\n      return this._numLetters;\n    }\n\n    set numLetters(n) {\n      this._numLettersForNextGame = n;\n    }\n\n    get numHops() {\n      return this._numHops;\n    }\n\n    set numHops(n) {\n      this._numHopsForNextGame = n;\n    }\n\n    get message() {\n      return this._message;\n    }\n\n    get lastExecutionTime() {\n      return this._lastExecutionTime;\n    }\n\n  }\n\n  GameService.ɵfac = function GameService_Factory(t) {\n    return new (t || GameService)(i0.ɵɵinject(i1.DataService));\n  };\n\n  GameService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GameService,\n    factory: GameService.ɵfac\n  });\n  return GameService;\n})();","map":null,"metadata":{},"sourceType":"module"}